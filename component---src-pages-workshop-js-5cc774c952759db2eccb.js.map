{"version":3,"sources":["webpack:///./src/pages/workshop.js","webpack:///./src/pages/workshop.module.scss","webpack:///./node_modules/hammerjs/hammer.js"],"names":["WorkShopPage","props","container","tween","state","color","componentDidMount","viewerImage","document","getElementById","hammertime","Hammer","this","TimelineLite","paused","to","y","get","set","direction","DIRECTION_VERTICAL","on","e","console","log","play","textContent","type","reverse","componentWillUnmount","render","ref","div","id","className","styles","card","children","React","Component","module","exports","window","exportName","undefined","assign","VENDOR_PREFIXES","TEST_ELEMENT","createElement","round","Math","abs","now","Date","setTimeoutContext","fn","timeout","context","setTimeout","bindFn","invokeArrayArg","arg","Array","isArray","each","obj","iterator","i","forEach","length","call","hasOwnProperty","deprecate","method","name","message","deprecationMessage","Error","stack","replace","warn","apply","arguments","Object","target","TypeError","output","index","source","nextKey","extend","dest","src","merge","keys","inherit","child","base","properties","childP","baseP","prototype","create","constructor","_super","boolOrFn","val","args","ifUndefined","val1","val2","addEventListeners","types","handler","splitStr","addEventListener","removeEventListeners","removeEventListener","hasParent","node","parent","parentNode","inStr","str","find","indexOf","trim","split","inArray","findByKey","toArray","slice","uniqueArray","key","sort","results","values","push","a","b","prefixed","property","prefix","prop","camelProp","toUpperCase","_uniqueId","getWindowForElement","element","doc","ownerDocument","defaultView","parentWindow","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","test","navigator","userAgent","PROPS_XY","PROPS_CLIENT_XY","Input","manager","callback","self","options","inputTarget","domHandler","ev","enable","init","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","isFinal","session","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","deltaTime","angle","getAngle","distance","getDistance","offset","offsetDelta","prevDelta","prevInput","x","deltaX","deltaY","computeDeltaXY","offsetDirection","getDirection","overallVelocity","getVelocity","overallVelocityX","overallVelocityY","scale","start","end","rotation","getRotation","maxPointers","velocity","velocityX","velocityY","last","lastInterval","v","computeIntervalInputData","srcEvent","computeInputData","emit","recognize","clientX","clientY","p1","p2","sqrt","atan2","PI","evEl","evTarget","evWin","destroy","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","MouseInput","pressed","button","which","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","2","3","4","5","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","PointerEventInput","store","pointerEvents","MSPointerEvent","PointerEvent","removePointer","eventTypeNormalized","toLowerCase","isTouch","storeIndex","pointerId","splice","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","SingleTouchInput","started","normalizeSingleTouches","all","touches","changed","changedTouches","concat","TOUCH_INPUT_MAP","TouchInput","targetIds","getTouches","allTouches","identifier","targetTouches","changedTargetTouches","filter","touch","TouchMouseInput","mouse","primaryTouch","lastTouches","recordTouches","eventData","setLastTouch","lastTouch","lts","isSyntheticEvent","t","dx","dy","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","PREFIXED_TOUCH_ACTION","style","NATIVE_TOUCH_ACTION","TOUCH_ACTION_MAP","touchMap","cssSupports","CSS","supports","getTouchActionProps","TouchAction","value","compute","actions","update","touchAction","recognizers","recognizer","getTouchAction","hasPanX","hasPanY","cleanTouchActions","join","preventDefaults","prevented","preventDefault","hasNone","isTapPointer","isTapMovement","isTapTouchTime","DIRECTION_LEFT","DIRECTION_UP","preventSrc","Recognizer","defaults","simultaneous","requireFail","stateStr","directionStr","getRecognizerByNameIfManager","otherRecognizer","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","preset","Manager","recognizeWith","dropRecognizeWith","requireFailure","dropRequireFailure","hasRequireFailures","canRecognizeWith","event","additionalEvent","tryEmit","canEmit","inputDataClone","reset","process","attrTest","optionPointers","isRecognized","isValid","threshold","DIRECTION_HORIZONTAL","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","clearTimeout","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","VERSION","domEvents","inputClass","cssProps","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","handlers","oldCssProps","toggleCssProps","item","add","stop","force","stopped","curRecognizer","existing","remove","events","off","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","triggerDomEvent","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","STATE_FAILED","DIRECTION_NONE","DIRECTION_RIGHT","DIRECTION_DOWN","DIRECTION_ALL","Tap","Pan","Swipe","Pinch","Rotate","Press"],"mappings":"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","file":"component---src-pages-workshop-js-5cc774c952759db2eccb.js","sourcesContent":["import React from \"react\"\r\n\r\nimport styles from \"./workshop.module.scss\"\r\n\r\nimport Layout from \"../components/layout\"\r\nimport Hammer from \"hammerjs\"\r\nimport { TimelineLite } from \"gsap/all\"\r\n\r\nclass WorkShopPage extends React.Component {\r\n  constructor(props) {\r\n    super(props)\r\n\r\n    // logo container\r\n    this.container = null\r\n    // objects\r\n    this.tween = null\r\n\r\n    this.state = {\r\n      color: \"#FFF\",\r\n    }\r\n  }\r\n\r\n  componentDidMount() {\r\n    const viewerImage = document.getElementById(\"myElement\")\r\n    const hammertime = new Hammer(viewerImage)\r\n    this.tween = new TimelineLite({ paused: true }).to(this.container, 2, {\r\n      y: 100,\r\n    })\r\n    hammertime.get(\"swipe\").set({ direction: Hammer.DIRECTION_VERTICAL })\r\n    hammertime.on(\"swipedown\", e => {\r\n      console.log(\"HAMMERTIME: TAP\")\r\n      this.tween.play()\r\n      viewerImage.textContent = e.type + \" gesture detected\"\r\n    })\r\n    hammertime.on(\"swipeup\", e => {\r\n      viewerImage.textContent = e.type + \" gesture detected\"\r\n      this.tween.reverse()\r\n      //window.location.replace(\"e24.no\")\r\n      //navigate(\"test\")\r\n    })\r\n  }\r\n\r\n  componentWillUnmount() {}\r\n\r\n  render() {\r\n    return (\r\n      <Layout>\r\n        <div\r\n          ref={div => (this.container = div)}\r\n          id=\"myElement\"\r\n          className={styles.card}\r\n        >\r\n          {this.props.children}workshop\r\n        </div>\r\n      </Layout>\r\n    )\r\n  }\r\n}\r\nexport default WorkShopPage\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"card\":\"workshop-module--card--3x-hd\"};","require(\"core-js/modules/es6.array.filter\");\n\nrequire(\"core-js/modules/es6.array.sort\");\n\nrequire(\"core-js/modules/es6.string.trim\");\n\nrequire(\"core-js/modules/es6.regexp.split\");\n\nrequire(\"core-js/modules/es6.array.index-of\");\n\nrequire(\"core-js/modules/es6.object.create\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nrequire(\"core-js/modules/es6.object.keys\");\n\nrequire(\"core-js/modules/es6.object.assign\");\n\nrequire(\"core-js/modules/es6.regexp.replace\");\n\nrequire(\"core-js/modules/es6.array.for-each\");\n\nrequire(\"core-js/modules/es6.array.is-array\");\n\nrequire(\"core-js/modules/es6.date.now\");\n\n/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function (window, document, exportName, undefined) {\n  'use strict';\n\n  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n  var TEST_ELEMENT = document.createElement('div');\n  var TYPE_FUNCTION = 'function';\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n  /**\n   * set a timeout with a given scope\n   * @param {Function} fn\n   * @param {Number} timeout\n   * @param {Object} context\n   * @returns {number}\n   */\n\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n  /**\n   * if the argument is an array, we want to execute the fn on each entry\n   * if it aint an array we don't want to do a thing.\n   * this is used by all the methods that accept a single and array argument.\n   * @param {*|Array} arg\n   * @param {String} fn\n   * @param {Object} [context]\n   * @returns {Boolean}\n   */\n\n\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * walk objects and arrays\n   * @param {Object} obj\n   * @param {Function} iterator\n   * @param {Object} context\n   */\n\n\n  function each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n      return;\n    }\n\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n      i = 0;\n\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n  /**\n   * wrap a method with a deprecation warning and stack trace\n   * @param {Function} method\n   * @param {String} name\n   * @param {String} message\n   * @returns {Function} A new function wrapping the supplied method.\n   */\n\n\n  function deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function () {\n      var e = new Error('get-stack-trace');\n      var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n      var log = window.console && (window.console.warn || window.console.log);\n\n      if (log) {\n        log.call(window.console, deprecationMessage, stack);\n      }\n\n      return method.apply(this, arguments);\n    };\n  }\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} target\n   * @param {...Object} objects_to_assign\n   * @returns {Object} target\n   */\n\n\n  var assign;\n\n  if (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var output = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n\n      return output;\n    };\n  } else {\n    assign = Object.assign;\n  }\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]\n   * @returns {Object} dest\n   */\n\n\n  var extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n\n    while (i < keys.length) {\n      if (!merge || merge && dest[keys[i]] === undefined) {\n        dest[keys[i]] = src[keys[i]];\n      }\n\n      i++;\n    }\n\n    return dest;\n  }, 'extend', 'Use `assign`.');\n  /**\n   * merge the values from src in the dest.\n   * means that properties that exist in dest will not be overwritten by src\n   * @param {Object} dest\n   * @param {Object} src\n   * @returns {Object} dest\n   */\n\n  var merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n  }, 'merge', 'Use `assign`.');\n  /**\n   * simple class inheritance\n   * @param {Function} child\n   * @param {Function} base\n   * @param {Object} [properties]\n   */\n\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n      assign(childP, properties);\n    }\n  }\n  /**\n   * simple function bind\n   * @param {Function} fn\n   * @param {Object} context\n   * @returns {Function}\n   */\n\n\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n  /**\n   * let a boolean value also be a function that must return a boolean\n   * this first item in args will be used as the context\n   * @param {Boolean|Function} val\n   * @param {Array} [args]\n   * @returns {Boolean}\n   */\n\n\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n\n    return val;\n  }\n  /**\n   * use the val2 when val1 is undefined\n   * @param {*} val1\n   * @param {*} val2\n   * @returns {*}\n   */\n\n\n  function ifUndefined(val1, val2) {\n    return val1 === undefined ? val2 : val1;\n  }\n  /**\n   * addEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n\n\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.addEventListener(type, handler, false);\n    });\n  }\n  /**\n   * removeEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n\n\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.removeEventListener(type, handler, false);\n    });\n  }\n  /**\n   * find if a node is in the given parent\n   * @method hasParent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n\n\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n\n      node = node.parentNode;\n    }\n\n    return false;\n  }\n  /**\n   * small indexOf wrapper\n   * @param {String} str\n   * @param {String} find\n   * @returns {Boolean} found\n   */\n\n\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n  /**\n   * split string on whitespace\n   * @param {String} str\n   * @returns {Array} words\n   */\n\n\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n  /**\n   * find if a array contains the object using indexOf or a simple polyFill\n   * @param {Array} src\n   * @param {String} find\n   * @param {String} [findByKey]\n   * @return {Boolean|Number} false when not found, or the index\n   */\n\n\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n\n      while (i < src.length) {\n        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n          return i;\n        }\n\n        i++;\n      }\n\n      return -1;\n    }\n  }\n  /**\n   * convert array-like objects to real arrays\n   * @param {Object} obj\n   * @returns {Array}\n   */\n\n\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n  /**\n   * unique array with objects based on a key (like 'id') or just by the array's value\n   * @param {Array} src [{id:1},{id:2},{id:1}]\n   * @param {String} [key]\n   * @param {Boolean} [sort=False]\n   * @returns {Array} [{id:1},{id:2}]\n   */\n\n\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n\n      values[i] = val;\n      i++;\n    }\n\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n\n    return results;\n  }\n  /**\n   * get the prefixed property\n   * @param {Object} obj\n   * @param {String} property\n   * @returns {String|Undefined} prefixed\n   */\n\n\n  function prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n    var i = 0;\n\n    while (i < VENDOR_PREFIXES.length) {\n      prefix = VENDOR_PREFIXES[i];\n      prop = prefix ? prefix + camelProp : property;\n\n      if (prop in obj) {\n        return prop;\n      }\n\n      i++;\n    }\n\n    return undefined;\n  }\n  /**\n   * get a unique id\n   * @returns {number} uniqueId\n   */\n\n\n  var _uniqueId = 1;\n\n  function uniqueId() {\n    return _uniqueId++;\n  }\n  /**\n   * get the window object of an element\n   * @param {HTMLElement} element\n   * @returns {DocumentView|Window}\n   */\n\n\n  function getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return doc.defaultView || doc.parentWindow || window;\n  }\n\n  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n  var SUPPORT_TOUCH = ('ontouchstart' in window);\n  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n  var INPUT_TYPE_TOUCH = 'touch';\n  var INPUT_TYPE_PEN = 'pen';\n  var INPUT_TYPE_MOUSE = 'mouse';\n  var INPUT_TYPE_KINECT = 'kinect';\n  var COMPUTE_INTERVAL = 25;\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n  var PROPS_XY = ['x', 'y'];\n  var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n  /**\n   * create new input type manager\n   * @param {Manager} manager\n   * @param {Function} callback\n   * @returns {Input}\n   * @constructor\n   */\n\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n\n  Input.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function handler() {},\n\n    /**\n     * bind the events\n     */\n    init: function init() {\n      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function destroy() {\n      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n  };\n  /**\n   * create new input type manager\n   * called by the Manager constructor\n   * @param {Hammer} manager\n   * @returns {Input}\n   */\n\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n      Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n      Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n      Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n      Type = MouseInput;\n    } else {\n      Type = TouchMouseInput;\n    }\n\n    return new Type(manager, inputHandler);\n  }\n  /**\n   * handle input events\n   * @param {Manager} manager\n   * @param {String} eventType\n   * @param {Object} input\n   */\n\n\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n      manager.session = {};\n    } // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n\n\n    input.eventType = eventType; // compute scale, rotation etc\n\n    computeInputData(manager, input); // emit secret event\n\n    manager.emit('hammer.input', input);\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n  /**\n   * extend the data with some usable properties like scale, rotate, velocity etc\n   * @param {Object} manager\n   * @param {Object} input\n   */\n\n\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    } // to compute scale and rotation we need to store the multiple touches\n\n\n    if (pointersLength > 1 && !session.firstMultiple) {\n      session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n    computeIntervalInputData(session, input); // find the correct target\n\n    var target = manager.element;\n\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n\n    input.target = target;\n  }\n\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n  /**\n   * velocity is calculated every x ms\n   * @param {Object} session\n   * @param {Object} input\n   */\n\n\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity,\n        velocityX,\n        velocityY,\n        direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n      var deltaX = input.deltaX - last.deltaX;\n      var deltaY = input.deltaY - last.deltaY;\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n  /**\n   * create a simple clone from the input used for storage of firstInput and firstMultiple\n   * @param {Object} input\n   * @returns {Object} clonedInputData\n   */\n\n\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        clientX: round(input.pointers[i].clientX),\n        clientY: round(input.pointers[i].clientY)\n      };\n      i++;\n    }\n\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n  /**\n   * get the center of all the pointers\n   * @param {Array} pointers\n   * @return {Object} center contains `x` and `y` properties\n   */\n\n\n  function getCenter(pointers) {\n    var pointersLength = pointers.length; // no need to loop when only one touch\n\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].clientX),\n        y: round(pointers[0].clientY)\n      };\n    }\n\n    var x = 0,\n        y = 0,\n        i = 0;\n\n    while (i < pointersLength) {\n      x += pointers[i].clientX;\n      y += pointers[i].clientY;\n      i++;\n    }\n\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Object} velocity `x` and `y`\n   */\n\n\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n  /**\n   * get the direction between two points\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Number} direction\n   */\n\n\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n  /**\n   * calculate the absolute distance between two points\n   * @param {Object} p1 {x, y}\n   * @param {Object} p2 {x, y}\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} distance\n   */\n\n\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.sqrt(x * x + y * y);\n  }\n  /**\n   * calculate the angle between two coordinates\n   * @param {Object} p1\n   * @param {Object} p2\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} angle\n   */\n\n\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n  }\n  /**\n   * calculate the rotation degrees between two pointersets\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} rotation\n   */\n\n\n  function getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n  }\n  /**\n   * calculate the scale factor between two pointersets\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} scale\n   */\n\n\n  function getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n  }\n\n  var MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n  };\n  var MOUSE_ELEMENT_EVENTS = 'mousedown';\n  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n  /**\n   * Mouse events input\n   * @constructor\n   * @extends Input\n   */\n\n  function MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n  }\n\n  inherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n      var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n      if (eventType & INPUT_START && ev.button === 0) {\n        this.pressed = true;\n      }\n\n      if (eventType & INPUT_MOVE && ev.which !== 1) {\n        eventType = INPUT_END;\n      } // mouse must be down\n\n\n      if (!this.pressed) {\n        return;\n      }\n\n      if (eventType & INPUT_END) {\n        this.pressed = false;\n      }\n\n      this.callback(this.manager, eventType, {\n        pointers: [ev],\n        changedPointers: [ev],\n        pointerType: INPUT_TYPE_MOUSE,\n        srcEvent: ev\n      });\n    }\n  });\n  var POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n  }; // in IE10 the pointer types is defined as an enum\n\n  var IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n  };\n  var POINTER_ELEMENT_EVENTS = 'pointerdown';\n  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\n  if (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n  }\n  /**\n   * Pointer events input\n   * @constructor\n   * @extends Input\n   */\n\n\n  function PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    Input.apply(this, arguments);\n    this.store = this.manager.session.pointerEvents = [];\n  }\n\n  inherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n      var store = this.store;\n      var removePointer = false;\n      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n      var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store\n\n      var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n        if (storeIndex < 0) {\n          store.push(ev);\n          storeIndex = store.length - 1;\n        }\n      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        removePointer = true;\n      } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n      if (storeIndex < 0) {\n        return;\n      } // update the event in the store\n\n\n      store[storeIndex] = ev;\n      this.callback(this.manager, eventType, {\n        pointers: store,\n        changedPointers: [ev],\n        pointerType: pointerType,\n        srcEvent: ev\n      });\n\n      if (removePointer) {\n        // remove from the store\n        store.splice(storeIndex, 1);\n      }\n    }\n  });\n  var SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n  /**\n   * Touch events input\n   * @constructor\n   * @extends Input\n   */\n\n  function SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n    Input.apply(this, arguments);\n  }\n\n  inherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n      var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n      if (type === INPUT_START) {\n        this.started = true;\n      }\n\n      if (!this.started) {\n        return;\n      }\n\n      var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n        this.started = false;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n\n  function normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n  }\n\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n  /**\n   * Multi-user touch events input\n   * @constructor\n   * @extends Input\n   */\n\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n    Input.apply(this, arguments);\n  }\n\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touches = getTouches.call(this, ev, type);\n\n      if (!touches) {\n        return;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n\n  function getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n      targetIds[allTouches[0].identifier] = true;\n      return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target; // get target touches from touches\n\n    targetTouches = allTouches.filter(function (touch) {\n      return hasParent(touch.target, target);\n    }); // collect touches\n\n    if (type === INPUT_START) {\n      i = 0;\n\n      while (i < targetTouches.length) {\n        targetIds[targetTouches[i].identifier] = true;\n        i++;\n      }\n    } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n    i = 0;\n\n    while (i < changedTouches.length) {\n      if (targetIds[changedTouches[i].identifier]) {\n        changedTargetTouches.push(changedTouches[i]);\n      } // cleanup removed touches\n\n\n      if (type & (INPUT_END | INPUT_CANCEL)) {\n        delete targetIds[changedTouches[i].identifier];\n      }\n\n      i++;\n    }\n\n    if (!changedTargetTouches.length) {\n      return;\n    }\n\n    return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n  }\n  /**\n   * Combined touch and mouse input\n   *\n   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n   * This because touch devices also emit mouse events while doing a touch.\n   *\n   * @constructor\n   * @extends Input\n   */\n\n\n  var DEDUP_TIMEOUT = 2500;\n  var DEDUP_DISTANCE = 25;\n\n  function TouchMouseInput() {\n    Input.apply(this, arguments);\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n    this.primaryTouch = null;\n    this.lastTouches = [];\n  }\n\n  inherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n          isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n\n      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n        return;\n      } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n      if (isTouch) {\n        recordTouches.call(this, inputEvent, inputData);\n      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n        return;\n      }\n\n      this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    }\n  });\n\n  function recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n      this.primaryTouch = eventData.changedPointers[0].identifier;\n      setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      setLastTouch.call(this, eventData);\n    }\n  }\n\n  function setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n      var lastTouch = {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n      this.lastTouches.push(lastTouch);\n      var lts = this.lastTouches;\n\n      var removeLastTouch = function removeLastTouch() {\n        var i = lts.indexOf(lastTouch);\n\n        if (i > -1) {\n          lts.splice(i, 1);\n        }\n      };\n\n      setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n  }\n\n  function isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX,\n        y = eventData.srcEvent.clientY;\n\n    for (var i = 0; i < this.lastTouches.length; i++) {\n      var t = this.lastTouches[i];\n      var dx = Math.abs(x - t.x),\n          dy = Math.abs(y - t.y);\n\n      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined; // magical touchAction value\n\n  var TOUCH_ACTION_COMPUTE = 'compute';\n  var TOUCH_ACTION_AUTO = 'auto';\n  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\n  var TOUCH_ACTION_NONE = 'none';\n  var TOUCH_ACTION_PAN_X = 'pan-x';\n  var TOUCH_ACTION_PAN_Y = 'pan-y';\n  var TOUCH_ACTION_MAP = getTouchActionProps();\n  /**\n   * Touch Action\n   * sets the touchAction property or uses the js alternative\n   * @param {Manager} manager\n   * @param {String} value\n   * @constructor\n   */\n\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  TouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function set(value) {\n      // find out the touch-action by the event handlers\n      if (value == TOUCH_ACTION_COMPUTE) {\n        value = this.compute();\n      }\n\n      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n      }\n\n      this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function update() {\n      this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function compute() {\n      var actions = [];\n      each(this.manager.recognizers, function (recognizer) {\n        if (boolOrFn(recognizer.options.enable, [recognizer])) {\n          actions = actions.concat(recognizer.getTouchAction());\n        }\n      });\n      return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function preventDefaults(input) {\n      var srcEvent = input.srcEvent;\n      var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n      if (this.manager.session.prevented) {\n        srcEvent.preventDefault();\n        return;\n      }\n\n      var actions = this.actions;\n      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n      if (hasNone) {\n        //do not prevent defaults if this is a tap gesture\n        var isTapPointer = input.pointers.length === 1;\n        var isTapMovement = input.distance < 2;\n        var isTapTouchTime = input.deltaTime < 250;\n\n        if (isTapPointer && isTapMovement && isTapTouchTime) {\n          return;\n        }\n      }\n\n      if (hasPanX && hasPanY) {\n        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n        return;\n      }\n\n      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n        return this.preventSrc(srcEvent);\n      }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function preventSrc(srcEvent) {\n      this.manager.session.prevented = true;\n      srcEvent.preventDefault();\n    }\n  };\n  /**\n   * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n   * @param {String} actions\n   * @returns {*}\n   */\n\n  function cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n      return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n\n    if (hasPanX && hasPanY) {\n      return TOUCH_ACTION_NONE;\n    } // pan-x OR pan-y\n\n\n    if (hasPanX || hasPanY) {\n      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    } // manipulation\n\n\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n      return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n  }\n\n  function getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n      return false;\n    }\n\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n      // If css.supports is not supported but there is native touch-action assume it supports\n      // all values. This is the case for IE 10 and 11.\n      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n  }\n  /**\n   * Recognizer flow explained; *\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\n   *\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n   * which determines with state it should be.\n   *\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n   * POSSIBLE to give it another change on the next cycle.\n   *\n   *               Possible\n   *                  |\n   *            +-----+---------------+\n   *            |                     |\n   *      +-----+-----+               |\n   *      |           |               |\n   *   Failed      Cancelled          |\n   *                          +-------+------+\n   *                          |              |\n   *                      Recognized       Began\n   *                                         |\n   *                                      Changed\n   *                                         |\n   *                                  Ended/Recognized\n   */\n\n\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n  /**\n   * Recognizer\n   * Every recognizer needs to extend from this class.\n   * @constructor\n   * @param {Object} options\n   */\n\n  function Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.options.enable = ifUndefined(this.options.enable, true);\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  Recognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function set(options) {\n      assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n      this.manager && this.manager.touchAction.update();\n      return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function recognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n        return this;\n      }\n\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n\n      return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function requireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n        return this;\n      }\n\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n\n      return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function dropRequireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n\n      return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function hasRequireFailures() {\n      return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function canRecognizeWith(otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function emit(input) {\n      var self = this;\n      var state = this.state;\n\n      function emit(event) {\n        self.manager.emit(event, input);\n      } // 'panstart' and 'panmove'\n\n\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      } // panend and pancancel\n\n\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function tryEmit(input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      } // it's failing anyway\n\n\n      this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function canEmit() {\n      var i = 0;\n\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n\n        i++;\n      }\n\n      return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function recognize(inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?\n\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      } // reset when we've reached the end\n\n\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n\n      this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n      // so trigger an event\n\n      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n        this.tryEmit(inputDataClone);\n      }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function process(inputData) {},\n    // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function getTouchAction() {},\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function reset() {}\n  };\n  /**\n   * get a usable string, used as event postfix\n   * @param {Const} state\n   * @returns {String} state\n   */\n\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return 'cancel';\n    } else if (state & STATE_ENDED) {\n      return 'end';\n    } else if (state & STATE_CHANGED) {\n      return 'move';\n    } else if (state & STATE_BEGAN) {\n      return 'start';\n    }\n\n    return '';\n  }\n  /**\n   * direction cons to string\n   * @param {Const} direction\n   * @returns {String}\n   */\n\n\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return 'down';\n    } else if (direction == DIRECTION_UP) {\n      return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n      return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n      return 'right';\n    }\n\n    return '';\n  }\n  /**\n   * get a recognizer by name if it is bound to a manager\n   * @param {Recognizer|String} otherRecognizer\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer}\n   */\n\n\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n\n    return otherRecognizer;\n  }\n  /**\n   * This recognizer is just used as a base for the simple attribute recognizers.\n   * @constructor\n   * @extends Recognizer\n   */\n\n\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n\n  inherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n      /**\n       * @type {Number}\n       * @default 1\n       */\n      pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function attrTest(input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function process(input) {\n      var state = this.state;\n      var eventType = input.eventType;\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n\n        return state | STATE_CHANGED;\n      }\n\n      return STATE_FAILED;\n    }\n  });\n  /**\n   * Pan\n   * Recognized when the pointer is down and moved in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n    getTouchAction: function getTouchAction() {\n      var direction = this.options.direction;\n      var actions = [];\n\n      if (direction & DIRECTION_HORIZONTAL) {\n        actions.push(TOUCH_ACTION_PAN_Y);\n      }\n\n      if (direction & DIRECTION_VERTICAL) {\n        actions.push(TOUCH_ACTION_PAN_X);\n      }\n\n      return actions;\n    },\n    directionTest: function directionTest(input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY; // lock to axis?\n\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n\n      input.direction = direction;\n      return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n    attrTest: function attrTest(input) {\n      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n    },\n    emit: function emit(input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n\n      this._super.emit.call(this, input);\n    }\n  });\n  /**\n   * Pinch\n   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function attrTest(input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n    emit: function emit(input) {\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? 'in' : 'out';\n        input.additionalEvent = this.options.event + inOut;\n      }\n\n      this._super.emit.call(this, input);\n    }\n  });\n  /**\n   * Press\n   * Recognized when the pointer is down for x ms without any movement.\n   * @constructor\n   * @extends Recognizer\n   */\n\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n    this._timer = null;\n    this._input = null;\n  }\n\n  inherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9 // a minimal movement is ok, but keep it low\n\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_AUTO];\n    },\n    process: function process(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n      this._input = input; // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n\n      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(function () {\n          this.state = STATE_RECOGNIZED;\n          this.tryEmit();\n        }, options.time, this);\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n\n      return STATE_FAILED;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit(input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + 'up', input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n  /**\n   * Rotate\n   * Recognized when two or more pointer are moving in a circular motion.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function attrTest(input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n  });\n  /**\n   * Swipe\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n    getTouchAction: function getTouchAction() {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n    attrTest: function attrTest(input) {\n      var direction = this.options.direction;\n      var velocity;\n\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n\n      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n    emit: function emit(input) {\n      var direction = directionStr(input.offsetDirection);\n\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n\n      this.manager.emit(this.options.event, input);\n    }\n  });\n  /**\n   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n   * a single tap.\n   *\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n   * multi-taps being recognized.\n   * @constructor\n   * @extends Recognizer\n   */\n\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments); // previous time and center,\n    // used for tap counting\n\n    this.pTime = false;\n    this.pCenter = false;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  inherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_MANIPULATION];\n    },\n    process: function process(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n      this.reset();\n\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      } // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n\n\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n\n        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n\n        this._input = input; // if tap count matches we have recognized it,\n        // else it has began recognizing...\n\n        var tapCount = this.count % options.taps;\n\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(function () {\n              this.state = STATE_RECOGNIZED;\n              this.tryEmit();\n            }, options.interval, this);\n            return STATE_BEGAN;\n          }\n        }\n      }\n\n      return STATE_FAILED;\n    },\n    failTimeout: function failTimeout() {\n      this._timer = setTimeoutContext(function () {\n        this.state = STATE_FAILED;\n      }, this.options.interval, this);\n      return STATE_FAILED;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit() {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n  /**\n   * Simple way to create a manager with a default set of recognizers.\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n  }\n  /**\n   * @const {string}\n   */\n\n\n  Hammer.VERSION = '2.0.7';\n  /**\n   * default settings\n   * @namespace\n   */\n\n  Hammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n    [RotateRecognizer, {\n      enable: false\n    }], [PinchRecognizer, {\n      enable: false\n    }, ['rotate']], [SwipeRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }], [PanRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n      event: 'doubletap',\n      taps: 2\n    }, ['tap']], [PressRecognizer]],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n      /**\n       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userSelect: 'none',\n\n      /**\n       * Disable the Windows Phone grippers when pressing an element.\n       * @type {String}\n       * @default 'none'\n       */\n      touchSelect: 'none',\n\n      /**\n       * Disables the default callout shown when you touch and hold a touch target.\n       * On iOS, when you touch and hold a touch target such as a link, Safari displays\n       * a callout containing information about the link. This property allows you to disable that callout.\n       * @type {String}\n       * @default 'none'\n       */\n      touchCallout: 'none',\n\n      /**\n       * Specifies whether zooming is enabled. Used by IE10>\n       * @type {String}\n       * @default 'none'\n       */\n      contentZooming: 'none',\n\n      /**\n       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userDrag: 'none',\n\n      /**\n       * Overrides the highlight color shown when the user taps a link or a JavaScript\n       * clickable element in iOS. This property obeys the alpha value, if specified.\n       * @type {String}\n       * @default 'rgba(0,0,0,0)'\n       */\n      tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n  };\n  var STOP = 1;\n  var FORCED_STOP = 2;\n  /**\n   * Manager\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n\n  function Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n\n  Manager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function set(options) {\n      assign(this.options, options); // Options that need a little more setup\n\n      if (options.touchAction) {\n        this.touchAction.update();\n      }\n\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n\n      return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function stop(force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function recognize(inputData) {\n      var session = this.session;\n\n      if (session.stopped) {\n        return;\n      } // run the touch-action polyfill\n\n\n      this.touchAction.preventDefaults(inputData);\n      var recognizer;\n      var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n\n      var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n      // or when we're in a new session\n\n      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n        curRecognizer = session.curRecognizer = null;\n      }\n\n      var i = 0;\n\n      while (i < recognizers.length) {\n        recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n        if (session.stopped !== FORCED_STOP && ( // 1\n        !curRecognizer || recognizer == curRecognizer || // 2\n        recognizer.canRecognizeWith(curRecognizer))) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n\n\n        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n\n        i++;\n      }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function get(recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n\n      var recognizers = this.recognizers;\n\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function add(recognizer) {\n      if (invokeArrayArg(recognizer, 'add', this)) {\n        return this;\n      } // remove existing\n\n\n      var existing = this.get(recognizer.options.event);\n\n      if (existing) {\n        this.remove(existing);\n      }\n\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n      this.touchAction.update();\n      return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function remove(recognizer) {\n      if (invokeArrayArg(recognizer, 'remove', this)) {\n        return this;\n      }\n\n      recognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n      if (recognizer) {\n        var recognizers = this.recognizers;\n        var index = inArray(recognizers, recognizer);\n\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n          this.touchAction.update();\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function on(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n\n      if (handler === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handler);\n      });\n      return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function off(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        if (!handler) {\n          delete handlers[event];\n        } else {\n          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function emit(event, data) {\n      // we also want to trigger dom events\n      if (this.options.domEvents) {\n        triggerDomEvent(event, data);\n      } // no handlers, so skip it all\n\n\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n\n      if (!handlers || !handlers.length) {\n        return;\n      }\n\n      data.type = event;\n\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault();\n      };\n\n      var i = 0;\n\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function destroy() {\n      this.element && toggleCssProps(this, false);\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   * @param {Manager} manager\n   * @param {Boolean} add\n   */\n\n  function toggleCssProps(manager, add) {\n    var element = manager.element;\n\n    if (!element.style) {\n      return;\n    }\n\n    var prop;\n    each(manager.options.cssProps, function (value, name) {\n      prop = prefixed(element.style, name);\n\n      if (add) {\n        manager.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value;\n      } else {\n        element.style[prop] = manager.oldCssProps[prop] || '';\n      }\n    });\n\n    if (!add) {\n      manager.oldCssProps = {};\n    }\n  }\n  /**\n   * trigger dom event\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  function triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n  }\n\n  assign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n  }); // this prevents errors when Hammer is loaded in the presence of an AMD\n  //  style loader but by script tag, not by the loader.\n\n  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n\n  freeGlobal.Hammer = Hammer;\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return Hammer;\n    });\n  } else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n  } else {\n    window[exportName] = Hammer;\n  }\n})(window, document, 'Hammer');"],"sourceRoot":""}